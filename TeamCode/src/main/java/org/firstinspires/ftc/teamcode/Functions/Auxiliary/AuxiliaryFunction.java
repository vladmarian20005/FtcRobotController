package org.firstinspires.ftc.teamcode.Functions.Auxiliary;

import androidx.annotation.NonNull;

import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareDevice;
import com.qualcomm.robotcore.hardware.Servo;
import com.sun.tools.javac.util.List;

abstract public class AuxiliaryFunction {

    public List<DcMotor> dcMotors;
    public List<Servo> servos;
    public OpMode main;


    /**
     * The status variables may be true (vacuum is on) or false (vacuum is off).
     */
    private boolean status;
    private boolean statusReverse;

    /**
     *
     * AUTHOR NOTES:
     *      * To use this class to create a new class and write "extends AuxiliaryFunction" right after the class declaration. Example: public class YourClassName extends AuxiliaryFunction
     *      * all of the necessary methods methods can be AUTOGENERATED by the editor, hover your mouse over the line "public class YourClassName extends AuxiliaryFunction" and press ALT+SHIFT+ENTER twice
     *      * you can access all the DCMotors and servos using dcMotors.get(i) or servos.get(j)
     *      * DO NOT CALL ANY OF THESE METHODS FROM OpMode/LinearOpMode or other CLASSES!
     *      *** USE THE FOLLOWING METHODS INSTEAD: Start(), StartReverse(), Stop(), Switch(), SwitchReverse(), SwitchAndWait(), SwitchAndWaitReverse()
     *      * any modification in AuxiliaryFunction will update all the auxiliary functions at once
     *      * if this class presents any problems during implementation contact the author (Durdeu Vlad) via messenger
     *
     *  This method initialises the motors and servos and separates them into two lists
     *  @param main : put "this" here or a reference to the OpMode/LinearOpMode class;
     *  @param hardwareDevices : dcMotors and servos in any order, you can put any HardwareDevice class here, but it will discard anything else
     */
    public AuxiliaryFunction(OpMode main, HardwareDevice... hardwareDevices){
        this.main = main;
        for(HardwareDevice hardwareDevice : hardwareDevices){
            if(hardwareDevice instanceof DcMotor) {
                this.dcMotors.append((DcMotor) hardwareDevice);
            }
            else if(hardwareDevice instanceof Servo){
                this.servos.append((Servo) hardwareDevice);
            }
        }
        status = false;
        statusReverse = false;
    }

    /**
     * This method holds the code regarding starting the motors/servos
     * DO NOT CALL THIS CLASS FROM Opmode/LinearOpMode CLASSES! USE METHOD Start() INSTEAD
     * OTHERWISE IT WILL BUG OUT BECAUSE THIS METHOD DOES NOT CHANGE THE STATUS!!
     */
    abstract void StartCode();

    /**
     * This method starts the motors.
     * CALL THIS METHOD INSTEAD OF STARTCODE() IN Opmode/LinearOpMode CLASSES!
     */
    final public void Start(){
        status = true;
        statusReverse = false;
        StartCode();
    }

    /**
     * This method holds the code regarding starting the motors/servos
     * DO NOT CALL THIS METHOD FROM Opmode/LinearOpMode CLASSES! USE METHOD Start() INSTEAD
     * OTHERWISE IT WILL BUG OUT BECAUSE THIS METHOD DOES NOT CHANGE THE STATUS!!
     */
    abstract void StartReverseCode();
    /**
     * This method also starts the motors but in the opposite direction.
     * Can be @Override, just be sure you call this function as well by using super.StartReverse();
     */
    final public void StartReverse(){
        statusReverse = true;
        status = false;
        StartReverseCode();
    }

    /**
     * This method holds the code regarding starting the motors/servos
     * DO NOT CALL THIS CLASS FROM Opmode/LinearOpMode CLASSES! USE METHOD Start() INSTEAD
     * OTHERWISE IT WILL BUG OUT BECAUSE THIS METHOD DOES NOT CHANGE THE STATUS!!
     */
    abstract void StopCode();

    /**
     * This method stops the motors.
     * Can be @Override, just be sure you call this function as well by using super.Stop();;
     */
    final public void Stop(){
        status = false;
        statusReverse = false;
        StopCode();
    }

    /**
     * This method starts/stops depending on the value of status(variable).
     */
    public final void Switch(){
        if(status){
            Stop();
        }
        else{
            Start();
        }
    }

    /**
     * This method starts/stops in the opposite direction depending on the value of statusInv(variable).
     */
    public final void SwitchReverse(){
        if(statusReverse){
            Stop();
        }
        else{
            StartReverse();
        }
    }

    double currentWaitTime = 0;
    double currentTimeStamp = 0;

    /**
     * This method checks if x seconds have passed, and if that's true it changes in the opposite direction.
     * @param seconds: how many seconds to wait until method Switch() can run again
     */
    public final void SwitchAndWait(double seconds){
        if(currentWaitTime ==0|| currentTimeStamp + currentWaitTime <= main.getRuntime()){
            Switch();
            currentTimeStamp = main.getRuntime();
            currentWaitTime = seconds;
        }
    }

    double currentWaitTimeReverse = 0;
    double currentTimeStampReverse = 0;

    /**
     * This method checks if x seconds have passed, and if that's true it changes in the opposite direction.
     * @param seconds: how many seconds to wait until method SwitchReverse() can run again
     */
    public final void SwitchAndWaitReverse(double seconds){
        if(currentWaitTimeReverse ==0|| currentTimeStampReverse + currentWaitTimeReverse <= main.getRuntime()){
            SwitchReverse();
            currentTimeStampReverse = main.getRuntime();
            currentWaitTimeReverse = seconds;
        }
    }

    /**
     * Easy way to get a reference of a DcMotor,
     * @return : (DcMotor) This returns a reference of the DcMotor if position is not out of bounds, otherwise NULL
     */
    public final DcMotor getDcMotor(int position){
        if(position>=0 && dcMotors.size()>position)
            return dcMotors.get(position);
        else return null;
    }

    /**
     * Easy way to get the reference of a Servo,
     * @return : (Servo) This returns a reference of the Servo if position is not out of bounds, otherwise NULL
     */
    public final Servo getServo(int position){
        if(position>=0 && servos.size()>position)
            return servos.get(position);
        else return null;
    }

    /**
     * Easy way to set the power of a DcMotor
     * @param pos : the position of the wanted DcMotor
     * @param power : must be between -1 and 1
     */
    public final void setDcMotorPower(int pos, double power){
        getDcMotor(pos).setPower(power);
    }

    /**
     * Easy way to set the position of a Servo
     * @param pos : the position of the wanted servo
     * @param position : must be between -1 and 1
     */
    public final void setServoPosition(int pos, double position){ getServo(pos).setPosition(position); }

    /**
     * This is how to read/use status variable.
     * @return : (boolean) This returns value of status variable.
     */
    public final boolean CheckStatus(){
        return status;
    }

    /**
     * This is how to read/use status variable.
     * @return : (boolean) This returns value of statusReverse variable.
     */
    public final boolean CheckStatusReverse(){
        return statusReverse;
    }
}
